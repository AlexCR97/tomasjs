export type ProblemDetailsOptions = {
  type: string;
  status: number;
  title: string;
  details?: string;
  instance: string;
  extensions?: Record<string, any>;
};

/**
 * A machine-readable format for specifying errors in HTTP API responses based on https://tools.ietf.org/html/rfc7807.
 */
export class ProblemDetails {
  /**
   * A URI reference [RFC3986] that identifies the problem type.
   * This specification encourages that, when dereferenced, it provides human-readable
   * documentation for the problem type (e.g., using HTML [W3C.REC-html5-20141028]).
   */
  readonly type: string;

  /**
   * The HTTP status code ([RFC7231], Section 6) generated by the origin server for
   * this occurrence of the problem.
   */
  readonly status: number;

  /**
   * A short, human-readable summary of the problem type.
   * It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes
   * of localization (e.g., using proactive content negotiation; see[RFC7231], Section 3.4).
   */
  readonly title: string;

  /**
   * A human-readable explanation specific to this occurrence of the problem.
   */
  readonly details?: string;

  /**
   * A URI reference that identifies the specific occurrence of the problem.
   * It may or may not yield further information if dereferenced.
   */
  readonly instance: string;

  /**
   * Problem type definitions MAY extend the problem details object with additional members.
   * Clients consuming problem details MUST ignore any such extensions that they don't recognize;
   * this allows problem types to evolve and include additional information in the future.
   */
  readonly extensions: Record<string, any>;

  constructor(options: ProblemDetailsOptions) {
    this.type = options.type;
    this.status = options.status;
    this.title = options.title;
    this.details = options.details;
    this.instance = options.instance;
    this.extensions = options.extensions ?? {};
  }

  withExtension(key: string, value: any): ProblemDetails {
    this.extensions[key] = value;
    return this;
  }

  toPlain(): Record<string, any> {
    const plain: Record<string, any> = {
      type: this.type,
      status: this.status,
      title: this.title,
      details: this.details,
      instance: this.instance,
    };

    for (const key of Object.keys(this.extensions)) {
      plain[key] = this.extensions[key];
    }

    return plain;
  }
}
